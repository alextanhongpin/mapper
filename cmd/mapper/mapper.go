package main

import (
	"fmt"
	"go/types"
	"log"

	"github.com/alextanhongpin/mapper"
	"github.com/dave/jennifer/jen"
	. "github.com/dave/jennifer/jen"
)

const GeneratorName = "mapper"

func main() {
	if err := mapper.New(func(opt mapper.Option) error {
		gen := NewGenerator(opt)
		return gen.Generate()
	}); err != nil {
		log.Fatalln(err)
	}
}

type Generator struct {
	opt     mapper.Option
	uses    map[string]mapper.Type
	mappers map[string]bool
}

func NewGenerator(opt mapper.Option) *Generator {
	return &Generator{
		opt:     opt,
		uses:    make(map[string]mapper.Type),
		mappers: make(map[string]bool),
	}
}

func (g *Generator) Generate() error {
	var (
		pkgName = g.opt.PkgName
		typ     = g.opt.Type
		out     = g.opt.Out
	)

	f := NewFile(pkgName) // e.g. main
	f.PackageComment(fmt.Sprintf("Code generated by %s, DO NOT EDIT.", GeneratorName))

	var stmts []*Statement

	// Cache first so that we can re-use later.
	for _, converter := range typ.InterfaceMethods {
		g.mappers[converter.NormalizedSignature()] = false
	}
	for _, converter := range typ.InterfaceMethods {
		if g.mappers[converter.NormalizedSignature()] {
			continue
		}
		stmt := g.generatePrivateMethod(Null(), converter)
		stmts = append(stmts, stmt)
		g.mappers[converter.NormalizedSignature()] = true
	}

	// The validation is done after the private methods are generated.
	for _, method := range typ.InterfaceMethods {
		g.validateToAndFromStruct(method)
	}

	// TODO: Inject dependency injection.
	g.generateConverter(f)
	g.generateConverterConstructor(f)

	for _, stmt := range stmts {
		f.Add(stmt)
	}

	for _, converter := range typ.InterfaceMethods {
		// There is a normalized private method mapper, use it.
		if _, found := g.mappers[converter.NormalizedSignature()]; !found {
			panic("mapper: method not found")
		}
		g.generateUsePrivateMethod(f, converter)
	}

	return f.Save(out) // e.g. main_gen.go
}

func (g *Generator) generateConverter(f *jen.File) {
	// Output:
	//type Converter struct {
	//  structName *structPkg.StructName
	//}

	f.Type().Id(g.opt.TypeName).StructFunc(func(s *Group) {
		for typeName, use := range g.uses {
			if use.IsStruct {
				s.Add(Id(typeName), Op("*").Qual(relativeTo(g.opt.PkgPath, use.PkgPath), use.Type))
			} else if use.IsInterface {
				s.Add(Id(typeName), Qual(relativeTo(g.opt.PkgPath, use.PkgPath), use.Type))
			} else {
				panic("mapper: not implemented")
			}
		}
	}).Line()
}

func (g *Generator) generateConverterConstructor(f *jen.File) {
	// Output:
	// func NewConverter(structType *CustomStruct) *Converter {
	//   return &Converter{
	//     structType: structType,
	//   }
	// }
	typeName := g.opt.TypeName

	f.Func().Id(fmt.Sprintf("New%s", typeName)).ParamsFunc(func(group *Group) {
		for structName, use := range g.uses {
			if use.IsStruct {
				group.Add(Id(structName), Op("*").Qual(relativeTo(g.opt.PkgPath, use.PkgPath), use.Type))
			} else if use.IsInterface {
				group.Add(Id(structName), Qual(relativeTo(g.opt.PkgPath, use.PkgPath), use.Type))
			} else {
				panic("mapper: not implemented")
			}
		}
	}).Op("*").Id(typeName).Block(
		Return(Op("&").Id(typeName).ValuesFunc(func(group *Group) {
			dict := make(Dict)
			for structName, use := range g.uses {
				if use.IsStruct || use.IsInterface {
					dict[Id(structName)] = Id(structName)
				}
			}
			group.Add(dict)
		})),
	).Line()
}

// generatePrivateMethod generates the most basic type for the given function
// to be reused for slice mapping.
func (g *Generator) generatePrivateMethod(f *jen.Statement, fn mapper.Func) *jen.Statement {
	var (
		pkgPath  = g.opt.PkgPath
		typeName = g.opt.TypeName
	)

	// Output:
	// func (c *Converter) mapMainAToMainB(a A) (B, error) {
	//   aID, err := CustomFunc(a.ID)
	//   if err != nil {
	//     return B{}, err
	//   }
	//   return B{
	//     ID: a.ID,
	//     Name: a.Name,
	//   }, nil
	// }

	fnName := fn.NormalizedName()
	from, to := fn.From, fn.To

	// Used to store if the method should return error.
	// If one of the callers returns error, it must erturn error.
	hasError := fn.Error != nil

	dict := Dict{}

	type mapperFunc struct {
		Fn         *mapper.Func
		In         mapper.StructField
		structName string
	}
	var funcsWithError []mapperFunc
	var methodsWithError []mapper.Func
	var embeddedStructMethodsWithError []mapperFunc
	var privateMapperMethodsWithError []mapperFunc

	for key, t := range to.Type.StructFields {

		// Check if there is a field mapping.
		f, ok := from.Type.StructFields[key]
		if ok {
			// `map:"CustomField,CustomFunc"`
			if tag := f.Tag; tag != nil && tag.HasFunc() {
				if tag.IsFunc() {
					fieldPkgPath := pkgPath
					if tag.IsImported() {
						fieldPkgPath = tag.PkgPath
					}

					// Load the function.
					pkg := mapper.LoadPackage(fieldPkgPath)
					obj := mapper.LookupType(pkg, tag.Func)
					if obj == nil {
						panic(fmt.Sprintf("mapper: func not found: %s", tag.Func))
					}

					fnType, ok := obj.(*types.Func)
					if !ok {
						panic(fmt.Sprintf("mapper: not a func: %s", tag.Func))
					}

					fn := mapper.ExtractFunc(fnType)
					if !fn.From.Type.Equal(f.Type) {
						panic(ErrMismatchType(fn.From.Type, f.Type))
					}

					if !fn.To.Type.Equal(t.Type) {
						panic(ErrMismatchType(fn.To.Type, t.Type))
					}

					if fn.Error != nil {
						funcsWithError = append(funcsWithError, mapperFunc{
							Fn: fn,
							In: f,
						})
						// Name: aName,
						dict[Id(t.Name)] = Id(argsWithIndex(from.Name, 0) + f.Name)
						continue
					}

					if tag.IsImported() {
						// Name: uuid.Parse(a.Name)
						dict[Id(t.Name)] = Qual(fn.PkgPath, fn.Name).Call(Id(argsWithIndex(from.Name, 0)).Dot(f.Name))
					} else {
						// Name: ParseUUID(a.Name)
						dict[Id(t.Name)] = Id(fn.Name).Call(Id(argsWithIndex(from.Name, 0)).Dot(f.Name))
					}
				}

				if tag.IsMethod() {
					// Could either be a struct or interface.
					fieldPkgPath := pkgPath
					if tag.IsImported() {
						fieldPkgPath = tag.PkgPath
					}

					// Load the function.
					pkg := mapper.LoadPackage(fieldPkgPath)
					obj := mapper.LookupType(pkg, tag.TypeName)
					if obj == nil {
						panic(fmt.Sprintf("mapper: type not found: %s", tag.TypeName))
					}

					if _, ok := obj.Type().(*types.Named); !ok {
						panic("mapper: not a named type")
					}

					typ := mapper.NewType(obj.Type())
					switch {
					case typ.IsInterface:
						method := typ.InterfaceMethods[tag.Func]
						if !method.From.Type.Equal(f.Type) {
							panic(ErrMismatchType(method.From.Type, f.Type))
						}
						if method.To.Type.Type != t.Type.Type {
							panic(ErrMismatchType(method.To.Type, t.Type))
						}

						g.uses[mapper.LowerFirst(tag.TypeName)] = *typ
						if method.Error != nil {
							embeddedStructMethodsWithError = append(embeddedStructMethodsWithError, mapperFunc{
								Fn:         &method,
								In:         f,
								structName: mapper.LowerFirst(tag.TypeName),
							})
							// Name: aName,
							dict[Id(t.Name)] = Id(argsWithIndex(from.Name, 0) + f.Name)
							continue
						}

						// Name: c.interface.CustomMethod(a.Name)
						dict[Id(t.Name)] = Id("c").Dot(mapper.LowerFirst(tag.TypeName)).Dot(method.Name).Call(Id(argsWithIndex(from.Name, 0)).Dot(f.Name))
					case typ.IsStruct:
						method := typ.StructMethods[tag.Func]
						if !method.From.Type.Equal(f.Type) {
							panic(ErrMismatchType(method.From.Type, f.Type))
						}
						if !method.To.Type.Equal(t.Type) {
							panic(ErrMismatchType(method.To.Type, t.Type))
						}

						g.uses[mapper.LowerFirst(tag.TypeName)] = *typ
						if method.Error != nil {
							embeddedStructMethodsWithError = append(embeddedStructMethodsWithError, mapperFunc{
								Fn:         &method,
								In:         f,
								structName: mapper.LowerFirst(tag.TypeName),
							})
							// Name: aName,
							dict[Id(t.Name)] = Id(argsWithIndex(from.Name, 0) + f.Name)
							continue
						}

						// TODO: Validate logic here.
						if f.IsSlice != t.IsStruct {
							panic("mapper: input and output must be slices")
						}

						// Name: c.struct.CustomMethod(a.Name)
						dict[Id(t.Name)] = Id("c").Dot(mapper.LowerFirst(tag.TypeName)).Dot(method.Name).Call(Id(argsWithIndex(from.Name, 0)).Dot(f.Name))
					default:
						panic("mapper: not implemented" + f.Name)
					}
				}
				continue
			}

			if !f.Type.Equal(t.Type) {
				methodSignature := buildFnSignature(f.Type, t.Type)
				_, hasSignature := g.mappers[methodSignature]
				if !hasSignature {
					panic(ErrConversion(f.Type, t.Type))
				}

				// Implement conversion for that field using existing converters.
				for _, method := range g.opt.Type.InterfaceMethods {
					if method.NormalizedSignature() == methodSignature {
						if method.Error != nil || t.Type.IsSlice {
							// Name: a0Name,
							dict[Id(t.Name)] = Id(argsWithIndex(from.Name, 0) + f.Name)
							privateMapperMethodsWithError = append(privateMapperMethodsWithError, mapperFunc{
								Fn: &method,
								In: f,
							})
						} else {
							// TODO: Handle pointer, slice.
							// Name: c.mapAtoB(a.Name)
							dict[Id(t.Name)] = Id("c").Dot(method.NormalizedName()).Call(Id(argsWithIndex(from.Name, 0)).Dot(f.Name))
						}
						break
					}
				}
				continue
			}

			// Name: a.Name
			dict[Id(t.Name)] = Id(argsWithIndex(from.Name, 0)).Dot(f.Name)
			continue
		}

		// Check if there is a method with the name that returns the same signature.
		if m, ok := from.Type.StructMethods[key]; ok {
			// The name of the method matches the name of field, e.g. to.Age: from.Age()
			if m.To.Type.Type != t.Type.Type {
				panic("mapper: method signature found, but types are different")
			}
			if m.From != nil {
				panic("mapper: method must not accept any arguments")
			}

			// TODO: If this has error, handle the return errors.
			if m.Error != nil {
				// Name: aName,
				dict[Id(t.Name)] = Id(argsWithIndex(from.Name, 0) + m.Name)
				methodsWithError = append(methodsWithError, m)
			} else {
				// Name: a.Name()
				dict[Id(t.Name)] = Id(argsWithIndex(from.Name, 0)).Dot(m.Name).Call()
			}
		} else {
			panic("mapper: method signature not found")
		}
	}

	returnOnError := If(Id("err").Op("!=").Id("nil").Block(
		Return(
			List(
				Op(pointerOp(to.Type, "&")).Qual(relativeTo(pkgPath, to.Type.PkgPath), to.Type.Type).Values(Dict{}),
				Id("err"),
			),
		)),
	).Line()

	// For each methods that has error as the second return value,
	// initialize them and return it.
	genMethodsWithError := func(g *Group) {
		for _, fn := range methodsWithError {
			// aName, err := a.Name()
			// if err != nil {
			//	return Bar{}, err
			// }
			g.Add(List(Id(argsWithIndex(from.Name, 0)+fn.Name), Id("err")).Op(":=").Id(argsWithIndex(from.Name, 0)).Dot(fn.Name).Call())
			g.Add(returnOnError.Clone())
		}
	}

	genFuncsWithError := func(g *Group) {
		for _, fn := range funcsWithError {
			// aName, err := CustomFunc(a.Name)
			// if err != nil {
			//	return Bar{}, err
			// }
			g.Add(List(Id(argsWithIndex(from.Name, 0)+fn.In.Name), Id("err")).Op(":=").Qual(fn.Fn.PkgPath, fn.Fn.Name).Call(Id(argsWithIndex(from.Name, 0)).Dot(fn.In.Name)))
			g.Add(returnOnError.Clone())
		}
	}

	genEmbeddedStructMethodsWithError := func(g *Group) {
		for _, fn := range embeddedStructMethodsWithError {
			// aName, err := c.struct.CustomMethod(a.Name)
			// if err != nil {
			//	return Bar{}, err
			// }
			g.Add(List(Id(argsWithIndex(from.Name, 0)+fn.In.Name), Id("err")).Op(":=").Id("c").Dot(fn.structName).Dot(fn.Fn.Name).Call(Id(argsWithIndex(from.Name, 0)).Dot(fn.In.Name)))
			g.Add(returnOnError.Clone())
		}
	}

	gg := g
	genPrivateMapperMethodsWithError := func(g *Group) {
		for _, fn := range privateMapperMethodsWithError {
			inName := argsWithIndex(from.Name, 0)   // a0
			inVarName := Id(inName + fn.In.Name)    // a0Name
			selection := Id(inName).Dot(fn.In.Name) // a0.Name

			// []*B
			returnType := Do(func(s *Statement) {
				if fn.In.Type.IsSlice {
					s.Add(Index())
				}
				if fn.In.Type.IsPointer {
					s.Add(Op("*"))
				}
			}).Qual(relativeTo(gg.opt.PkgPath, fn.Fn.To.Type.PkgPath), fn.Fn.To.Type.Type)

			if fn.In.Type.IsSlice {
				// aName := make([]B, len(a.Name))
				g.Add(inVarName.Clone().Op(":=").Make(returnType, Len(selection.Clone())))

				if fn.Fn.Error != nil {
					// for i, each := range a.Name {
					//   var err error
					//   aName[i], err := c.mapAtoB(a.Name)
					//   if err != nil {
					//     return Bar{}, err
					//   }
					// }

					g.Add(For(List(Id("i"), Id("each")).Op(":=").Range().Add(selection.Clone())).Block(
						Var().Id("err").Id("error"),
						List(inVarName.Clone().Index(Id("i")), Id("err")).Op("=").Id("c").Dot(fn.Fn.NormalizedName()).Call(Id("each")),
						returnOnError.Clone(),
					))

				} else {
					// for i, each := range a.Name {
					//   aName[i] := c.mapAtoB(a.Name)
					// }
					g.Add(For(List(Id("i"), Id("each")).Op(":=").Range().Add(selection.Clone())).Block(
						inVarName.Clone().Index(Id("i")).Op("=").Id("c").Dot(fn.Fn.NormalizedName()).Call(Id("each")),
					))

				}
			} else {
				// aName, err := c.mapAtoB(a.Name)
				// if err != nil {
				//	return Bar{}, err
				// }
				g.Add(List(inVarName.Clone(), Id("err")).Op(":=").Id("c").Dot(fn.Fn.NormalizedName()).Call(selection.Clone()))
				g.Add(returnOnError.Clone())
			}
		}
	}

	genReturnType := func(s *Statement) {
		returnType := Do(func(s *Statement) {
			if to.Type.IsSlice {
				s.Add(Index())
			}
			if to.Type.IsPointer {
				s.Add(Op("*"))
			}
		}).Qual(relativeTo(pkgPath, to.Type.PkgPath), to.Type.Type)
		if fn.Error != nil {
			// (Bar, nil)
			s.Add(Parens(List(
				returnType,
				Id("error"),
			)))
		} else {
			// (Bar)
			s.Add(returnType)
		}
	}

	if !hasError && (len(funcsWithError)+len(methodsWithError)+len(embeddedStructMethodsWithError)+len(privateMapperMethodsWithError) > 0) {
		panic(ErrMissingReturnError(fn))
	}

	f.Func().
		Params(Id("c").Op("*").Id(typeName)). // (c *Converter)
		Id(fnName).                           // mapMainAToMainB
		Params(
			Id(argsWithIndex(from.Name, 0)).Qual(relativeTo(pkgPath, from.Type.PkgPath), from.Type.Type),
		). // (a A)
		Do(genReturnType).
		BlockFunc(func(g *Group) {
			// aName, err := a.Name()
			// if err != nil {
			//	return Bar{}, err
			// }
			genMethodsWithError(g)

			// aName, err := CustomFunc(a.Name)
			// if err != nil {
			//	return Bar{}, err
			// }
			genFuncsWithError(g)

			// aName, err := c.struct.CustomMethod(a.Name)
			// if err != nil {
			//	return Bar{}, err
			// }
			genEmbeddedStructMethodsWithError(g)

			// aName, err := c.mapAtoB(a.Name)
			// if err != nil {
			//	return Bar{}, err
			// }
			genPrivateMapperMethodsWithError(g)

			g.Add(ReturnFunc(func(g *Group) {
				if fn.Error != nil {
					// return Bar{}, nil
					g.Add(
						List(
							Op(pointerOp(to.Type, "&")).
								Qual(relativeTo(pkgPath, to.Type.PkgPath), to.Type.Type).Values(dict),
							Id("nil"),
						),
					)
				} else {
					// return Bar{}
					g.Add(
						Op(pointerOp(to.Type, "&")).
							Qual(relativeTo(pkgPath, to.Type.PkgPath), to.Type.Type).Values(dict))
				}
			}))
		}).Line()
	return f
}

func (g *Generator) generateUsePrivateMethod(f *jen.File, fn mapper.Func) {
	var (
		pkgPath  = g.opt.PkgPath
		typeName = g.opt.TypeName
	)
	// Output:
	// func (c *Converter) Convert(a A) (B, error) {
	//   b, err := c.mapMainAtoMainB(a.Field)
	//   return b, err
	// }

	from, to := fn.From, fn.To
	if from.Type.IsSlice != to.Type.IsSlice {
		panic("mapper: slice to no-slice and vice versa is not allowed")
	}
	isSlice := from.Type.IsSlice

	// main.A
	inType := Qual(relativeTo(pkgPath, from.Type.PkgPath), from.Type.Type)

	// main.B
	outType := Qual(relativeTo(pkgPath, to.Type.PkgPath), to.Type.Type)

	genInputType := func(g *Group) {
		g.Add(
			Id(argsWithIndex(from.Name, 0)).Do(func(s *Statement) {
				if from.Type.IsSlice {
					s.Add(Index())
				}
				// TODO: Not needed.
				if from.Type.IsPointer {
					s.Add(Op("*"))
				}
			}).Add(inType),
		)
	}

	genReturnType := func(s *Statement) {
		returnType := Do(func(rs *Statement) {
			// Output:
			// []main.B
			if to.Type.IsSlice {
				rs.Add(Index())
			}

			// Output:
			// []*main.B
			// TODO: Not required.
			if to.Type.IsPointer {
				rs.Add(Op("*"))
			}
		}).Op(pointerOp(to.Type, "*")).Add(outType)

		if fn.Error != nil {
			// (*Bar, error)
			s.Add(Parens(List(returnType, Id("error"))))
		} else {
			// (*Bar)
			s.Add(returnType)
		}
	}

	f.Func().
		Params(Id("c").Op("*").Id(typeName)). // (c *Converter)
		Id(fn.Name).ParamsFunc(genInputType). // Convert(a *A)
		Do(genReturnType).                    // (*B, error)
		BlockFunc(func(g *Group) {
			if isSlice {
				// var err error
				// res := make([]B, len(a))
				// for i, s := range a {
				//   res[i], err = c.mapMainAToMainB(s)
				//   if err != nil { return err }
				// }
				// return res, nil
				if fn.Error != nil {
					g.Add(Var().Id("err").Id("error"))
				}
				g.Add(Id("res").Op(":=").Make(List(Index().Add(outType), Len(Id(argsWithIndex(from.Name, 0))))))
				g.Add(For(List(Id("i"), Id("s")).Op(":=").Range().Id(argsWithIndex(from.Name, 0))).BlockFunc(func(g *Group) {
					if fn.Error != nil {
						g.Add(List(
							Id("res").Index(Id("i")),
							Id("err"),
						).Op("=").Id("c").Dot(fn.NormalizedName()).Call(Id("s")))
						g.Add(If(Id("err").Op("!=").Id("nil")).Block(ReturnFunc(func(g *Group) {
							if isSlice {
								g.Add(List(Id("nil"), Id("err")))
							} else {
								g.Add(List(outType.Clone().Values(), Id("err")))
							}
						})))
					} else {
						g.Add(Id("res").Index(Id("i")).Op("=").Id("c").Dot(fn.NormalizedName()).Call(Id("s")))
					}
				}))

				if fn.Error != nil {
					// return res, nil
					g.Add(Return(List(Id("res"), Id("nil"))))
				} else {
					// return res
					g.Add(Return(Id("res")))
				}
			} else {
				// return c.mapMainAToMainB(a)
				g.Add(Return(Id("c").Dot(fn.NormalizedName()).Call(Id(argsWithIndex(from.Name, 0)))))
			}
		}).Line()
}

func relativeTo(pkgPath, fieldPkgPath string) string {
	if pkgPath == fieldPkgPath {
		return ""
	}
	return fieldPkgPath
}

func pointerOp(m *mapper.Type, op string) string {
	if !m.IsPointer {
		return ""
	}
	return op
}

func argsWithIndex(name string, index int) string {
	return fmt.Sprintf("%s%d", name, index)
}

func (g *Generator) validateToAndFromStruct(fn mapper.Func) {
	from, to := fn.From, fn.To

	if from.Type.IsPointer {
		//if from.Type.IsPointer || to.Type.IsPointer {
		panic("mapper: struct pointer is not allowed")
	}

	fromFields := from.Type.StructFields
	fromMethods := from.Type.StructMethods

	// Check that the result struct has all the fields provided by the input
	// struct.
	for name, rhs := range to.Type.StructFields {
		if lhs, exists := fromFields[name]; exists {
			g.validateStructField(lhs, rhs)
			continue
		}
		if lhs, exists := fromMethods[name]; exists {
			g.validateMethodSignature(lhs, rhs)
			continue
		}
		panic(fmt.Sprintf("mapper: field not found: %s.%s does not have fields that maps to %s.%s(%s)",
			from.Type.Pkg,
			from.Name,
			to.Type.Pkg,
			name,
			to.Type.Type,
		))
	}
}

func (g *Generator) validateStructField(lhs, rhs mapper.StructField) {
	if !lhs.Type.Equal(rhs.Type) {
		// If one of the mappers already implement this, skip the error.
		if _, exists := g.mappers[buildFnSignature(lhs.Type, rhs.Type)]; exists {
			return
		}
		// There could also be a tag function.
		if lhs.Tag != nil {
			return
		}

		panic(ErrConversion(lhs.Type, rhs.Type))
	}
}

// validateMethodSignature checks if the lhs.method() returns the right
// signature required by rhs.
func (g *Generator) validateMethodSignature(lhs mapper.Func, rhs mapper.StructField) {
	if lhs.From != nil {
		panic(fmt.Sprintf("mapper: struct method should not have arguments %s.%s(%s %s)", lhs.Pkg, lhs.Name, lhs.From.Name, lhs.From.Type.Type))
	}

	// TODO: check if there is a local mapper that fulfils this type conversion.
	// This can only be from one of the converters.
	if !lhs.From.Type.Equal(rhs.Type) {
		panic(ErrConversion(lhs.To.Type, rhs.Type))
	}
}

func buildFnSignature(lhs, rhs *mapper.Type) string {
	fn := mapper.Func{
		From: &mapper.FuncArg{
			Type: lhs,
		},
		To: &mapper.FuncArg{
			Type: rhs,
		},
	}
	return fn.NormalizedSignature()
}

func ErrConversion(lhs, rhs *mapper.Type) error {
	return fmt.Errorf(`mapper: cannot convert %s to %s`,
		lhs.Signature(),
		rhs.Signature(),
	)
}

func ErrMismatchType(lhs, rhs *mapper.Type) error {
	return fmt.Errorf(`mapper: signature does not match: %s to %s`,
		lhs.Signature(),
		rhs.Signature(),
	)
}

func ErrMissingReturnError(fn mapper.Func) error {
	return fmt.Errorf("mapper: missing return err for %s", fn.PrettySignature())
}
