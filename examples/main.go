package main

import (
	"fmt"
	"go/types"
	"log"
	"strconv"

	"github.com/alextanhongpin/mapper"
	"github.com/alextanhongpin/mapper/examples/bar"
	"github.com/alextanhongpin/mapper/examples/foo"
	"github.com/dave/jennifer/jen"
	. "github.com/dave/jennifer/jen"
	"github.com/davecgh/go-spew/spew"
	"github.com/google/uuid"
)

const GeneratorName = "mapper"

type Task struct {
	Name string
}

func ParseUUID(id string) (uuid.UUID, error) {
	return uuid.Parse(id)
}

type Foo struct {
	//CustomID string `map:"ExternalID,ParseUUID"`
	CustomID string `map:"ExternalID,github.com/google/uuid/Parse"`
	FakeAge  int    `map:"Age"`
	name     string
	Task     Task
	id       string
	//Remarks string // Fail with extra fields now.
	// CustomName `mapper:"YourName"`
	// CustomMapper `mapper:"github.com/yourorganization/yourpackage/struct.Method"`
	// CustomInterface `mapper:"github.com/yourorganization/yourpackage/interface.Method"`
	// CustomFunction`mapper:"github.com/yourorganization/yourpackage.funcName"`
}

func (f Foo) ID() (uuid.UUID, error) {
	return uuid.Parse(f.id)
}

//func (f Foo) Name(ctx context.Context) string { // Panics, since it accepts arguments.
func (f Foo) Name() string {
	return f.name
}

func CustomConverter(a string) int {
	i, _ := strconv.Atoi(a)
	return i
}

//go:generate go run main.go -type Converter -suffix=Impl
type Converter interface {
	ConvertNameless(Foo) (Bar, error) // Accepts err.
	Convert(a Foo) (Bar, error)       // Accepts err.
	ConvertImport(f foo.Foo) (b bar.Bar, err error)
	// Pointers not accepted
	//ConvertReturnPointer(a Foo) (*Bar, error) // Accepts err.
	//ConvertImportPointer(f *foo.Foo) (b *bar.Bar, err error)
	//ConvertWithContext(ctx context.Context, foo Foo) (Bar)
	ConvertSlice(a []Foo) ([]Bar, error) // Accepts err.
	ConvertSliceWithoutErrors(a []A) []B // Accepts err.
	ConvertImportStruct(C) D
	ConvertImportStructWithError(D) (C, error)
}

type A struct {
	Name string
}

type B struct {
	Name string
}

type C struct {
	ID  int `json:"id" map:",CustomStructConverter.ConvertToString"`
	Age int `json:"age" map:",CustomInterfaceConverter.ConvertToString"`
}

type D struct {
	ID  string `map:",CustomStructConverter.ConvertToInt"`
	Age string `json:"age" map:",CustomInterfaceConverter.ConvertToInt"`
}

type CustomStructConverter struct {
}

func (c *CustomStructConverter) ConvertToString(n int) string {
	return fmt.Sprint(n)
}

func (c *CustomStructConverter) ConvertToInt(s string) (int, error) {
	return strconv.Atoi(s)
}

type CustomInterfaceConverter interface {
	ConvertToString(a int) string
	ConvertToInt(a string) (int, error)
}

type Bar struct {
	ID         uuid.UUID
	Name       string
	RealAge    int `json:"age" map:"Age"`
	Task       Task
	ExternalID uuid.UUID
}

func convert(c Converter) {
	fmt.Println(c.Convert(Foo{
		name:     "john",
		id:       uuid.New().String(),
		CustomID: uuid.New().String(),
	}))
}

func main() {
	if err := mapper.New(func(opt mapper.Option) error {
		gen := NewGenerator(opt)
		return gen.Generate()
	}); err != nil {
		log.Fatalln(err)
	}
}

type Generator struct {
	opt  mapper.Option
	uses map[string]mapper.Type
}

func NewGenerator(opt mapper.Option) *Generator {
	return &Generator{
		opt:  opt,
		uses: make(map[string]mapper.Type),
	}
}

func (g *Generator) Generate() error {
	var (
		pkgName = g.opt.PkgName
		typ     = g.opt.Type
		out     = g.opt.Out
	)

	f := NewFile(pkgName) // e.g. main
	f.PackageComment(fmt.Sprintf("Code generated by %s, DO NOT EDIT.", GeneratorName))

	privateMethods := make(map[string]bool)
	var stmts []*Statement
	for _, converter := range typ.InterfaceMethods {
		if converter.From.Type.IsPointer || converter.To.Type.IsPointer {
			panic("mapper: conversion to and/or from struct pointer is not allowed")
		}
		// Cannot convert pointers.
		// Cannot convert if error type is not fulfilled
		// Cannot convert struct to slice/or vice versa.
		if privateMethods[converter.NormalizedSignature()] {
			continue
		}
		stmt := g.generatePrivateMethod(Null(), converter)
		stmts = append(stmts, stmt)
		privateMethods[converter.NormalizedSignature()] = true
	}

	// TODO: Inject dependency injection.
	g.generateConverter(f)
	g.generateConverterConstructor(f)

	for _, stmt := range stmts {
		f.Add(stmt)
	}

	for _, converter := range typ.InterfaceMethods {
		// There is a normalized private method mapper, use it.
		if !privateMethods[converter.NormalizedSignature()] {
			panic("mapper: method not found")
		}
		g.generateUsePrivateMapper(f, converter)
	}

	return f.Save(out) // e.g. main_gen.go
}

func (g *Generator) generateConverter(f *jen.File) {
	// Output:
	//type Converter struct {
	//  structName *structPkg.StructName
	//}

	f.Type().Id(g.opt.TypeName).StructFunc(func(s *Group) {
		for typeName, use := range g.uses {
			if use.IsStruct {
				s.Add(Id(typeName), Op("*").Qual(relativeTo(g.opt.PkgPath, use.PkgPath), use.Type))
			} else if use.IsInterface {
				s.Add(Id(typeName), Qual(relativeTo(g.opt.PkgPath, use.PkgPath), use.Type))
			} else {
				panic("mapper: not implemented")
			}
		}
	}).Line()
}

func (g *Generator) generateConverterConstructor(f *jen.File) {
	// Output:
	// func NewConverter(structType *CustomStruct) *Converter {
	//   return &Converter{
	//     structType: structType,
	//   }
	// }
	typeName := g.opt.TypeName

	f.Func().Id(fmt.Sprintf("New%s", typeName)).ParamsFunc(func(group *Group) {
		for structName, use := range g.uses {
			if use.IsStruct {
				//dict[Id(structName)] = Op("*").Qual(relativeTo(g.opt.PkgPath, use.PkgPath), use.Type)
				group.Add(Id(structName), Op("*").Qual(relativeTo(g.opt.PkgPath, use.PkgPath), use.Type))
			} else if use.IsInterface {
				group.Add(Id(structName), Qual(relativeTo(g.opt.PkgPath, use.PkgPath), use.Type))
			} else {
				panic("mapper: not implemented")
			}
		}
	}).Op("*").Id(typeName).Block(
		Return(Op("&").Id(typeName).ValuesFunc(func(group *Group) {
			dict := make(Dict)
			for structName, use := range g.uses {
				if use.IsStruct || use.IsInterface {
					dict[Id(structName)] = Id(structName)
				}
			}
			group.Add(dict)
		})),
	).Line()
}

// generatePrivateMethod generates the most basic type for the given function
// to be reused for slice mapping.
func (g *Generator) generatePrivateMethod(f *jen.Statement, fn mapper.Func) *jen.Statement {
	var (
		pkgPath  = g.opt.PkgPath
		typeName = g.opt.TypeName
	)

	// Output:
	// func (c *Converter) mapMainAToMainB(a A) (B, error) {
	//   return B{
	//     ID: a.ID,
	//     Name: a.Name,
	//   }, nil
	// }

	fnName := fn.NormalizedName()
	from, to := fn.From, fn.To

	dict := Dict{}

	type mapperFunc struct {
		Fn         *mapper.Func
		In         mapper.StructField
		structName string
	}
	var funcsWithError []mapperFunc
	var methodsWithError []mapper.Func
	var embeddedStructMethodsWithError []mapperFunc
	for key, t := range to.Type.StructFields {

		// Check if there is a field mapping.
		f, ok := from.Type.StructFields[key]
		if ok {
			// `map:"CustomField,CustomFunc"`
			if tag := f.Tag; tag != nil && tag.HasFunc() {
				if tag.IsFunc() {
					fieldPkgPath := pkgPath
					if tag.IsImported() {
						fieldPkgPath = tag.PkgPath
					}

					// Load the function.
					pkg := mapper.LoadPackage(fieldPkgPath)
					obj := mapper.LookupType(pkg, tag.Func)
					if obj == nil {
						panic(fmt.Sprintf("mapper: func not found: %s", tag.Func))
					}

					fnType, ok := obj.(*types.Func)
					if !ok {
						panic(fmt.Sprintf("mapper: not a func: %s", tag.Func))
					}

					fn := mapper.ExtractFunc(fnType)
					if fn.From.Type.Type != f.Type.Type {
						panic(fmt.Sprintf("mapper: input signature does not match: %v != %v", fn.From.Type.Type, f.Type.Type))
					}
					if fn.To.Type.Type != t.Type.Type {
						panic(fmt.Sprintf("mapper: output signature does not match: %v != %v", fn.To.Type.Type, t.Type.Type))
					}

					if fn.Error != nil {
						funcsWithError = append(funcsWithError, mapperFunc{
							Fn: fn,
							In: f,
						})
						// Name: aName,
						dict[Id(t.Name)] = Id(argsWithIndex(from.Name, 0) + f.Name)
						continue
					}

					if tag.IsImported() {
						// Name: uuid.Parse(a.Name)
						dict[Id(t.Name)] = Qual(fn.PkgPath, fn.Name).Call(Id(argsWithIndex(from.Name, 0)).Dot(f.Name))
					} else {
						// Name: ParseUUID(a.Name)
						dict[Id(t.Name)] = Id(fn.Name).Call(Id(argsWithIndex(from.Name, 0)).Dot(f.Name))
					}
				}

				if tag.IsMethod() {
					// Could either be a struct or interface.
					fieldPkgPath := pkgPath
					if tag.IsImported() {
						fieldPkgPath = tag.PkgPath
					}

					// Load the function.
					pkg := mapper.LoadPackage(fieldPkgPath)
					obj := mapper.LookupType(pkg, tag.TypeName)
					if obj == nil {
						panic(fmt.Sprintf("mapper: type not found: %s", tag.TypeName))
					}

					if _, ok := obj.Type().(*types.Named); !ok {
						panic("mapper: not a named type")
					}

					typ := mapper.NewType(obj.Type())

					//typ := mapper.NewType(obj.Type())
					switch {
					case typ.IsInterface:
						method := typ.InterfaceMethods[tag.Func]
						if method.From.Type.Type != f.Type.Type {
							panic("mapper: method input type does not match")
						}
						if method.To.Type.Type != t.Type.Type {
							panic("mapper: method return type does not match")
						}
						if method.Error != nil {
							embeddedStructMethodsWithError = append(embeddedStructMethodsWithError, mapperFunc{
								Fn:         &method,
								In:         f,
								structName: mapper.LowerFirst(tag.TypeName),
							})
							// Name: aName,
							dict[Id(t.Name)] = Id(argsWithIndex(from.Name, 0) + f.Name)
							continue
						}
						g.uses[mapper.LowerFirst(tag.TypeName)] = *typ

						// Name: c.interface.CustomMethod(a.Name)
						dict[Id(t.Name)] = Id("c").Dot(mapper.LowerFirst(tag.TypeName)).Dot(method.Name).Call(Id(argsWithIndex(from.Name, 0)).Dot(f.Name))

					case typ.IsStruct:
						method := typ.StructMethods[tag.Func]
						if method.From.Type.Type != f.Type.Type {
							panic("mapper: method input type does not match")
						}
						if method.To.Type.Type != t.Type.Type {
							panic("mapper: method return type does not match")
						}
						if method.Error != nil {
							embeddedStructMethodsWithError = append(embeddedStructMethodsWithError, mapperFunc{
								Fn:         &method,
								In:         f,
								structName: mapper.LowerFirst(tag.TypeName),
							})
							// Name: aName,
							dict[Id(t.Name)] = Id(argsWithIndex(from.Name, 0) + f.Name)
							continue
						}
						g.uses[mapper.LowerFirst(tag.TypeName)] = *typ

						// Name: c.struct.CustomMethod(a.Name)
						dict[Id(t.Name)] = Id("c").Dot(mapper.LowerFirst(tag.TypeName)).Dot(method.Name).Call(Id(argsWithIndex(from.Name, 0)).Dot(f.Name))
					default:
						spew.Dump(typ)
						panic("mapper: not implemented" + f.Name)
					}
				}
				continue
			}

			// Name: a.Name
			dict[Id(t.Name)] = Id(argsWithIndex(from.Name, 0)).Dot(f.Name)
			continue
		}

		// Check if there is a method with the name that returns the same signature.
		if m, ok := from.Type.StructMethods[key]; ok {
			// The name of the method matches the name of field, e.g. to.Age: from.Age()
			if m.To.Type.Type != t.Type.Type {
				panic("mapper: method signature found, but types are different")
			}
			if m.From != nil {
				panic("mapper: method must not accept any arguments")
			}

			// TODO: If this has error, handle the return errors.
			if m.Error != nil {
				// Name: aName,
				dict[Id(t.Name)] = Id(argsWithIndex(from.Name, 0) + m.Name)
				methodsWithError = append(methodsWithError, m)
			} else {
				// Name: a.Name()
				dict[Id(t.Name)] = Id(argsWithIndex(from.Name, 0)).Dot(m.Name).Call()
			}
		} else {
			panic("mapper: method signature not found")
		}
	}

	returnOnError := If(Id("err").Op("!=").Id("nil").Block(
		Return(
			List(
				Qual(relativeTo(pkgPath, to.Type.PkgPath), to.Type.Type).Values(Dict{}),
				Id("err"),
			),
		)),
	).Line()

	// For each methods that has error as the second return value,
	// initialize them and return it.
	genMethodsWithError := func(g *Group) {
		for _, fn := range methodsWithError {
			// aName, err := a.Name()
			// if err != nil {
			//	return Bar{}, err
			// }
			g.Add(List(Id(argsWithIndex(from.Name, 0)+fn.Name), Id("err")).Op(":=").Id(argsWithIndex(from.Name, 0)).Dot(fn.Name).Call())
			g.Add(returnOnError.Clone())
		}
	}

	genFuncsWithError := func(g *Group) {
		for _, fn := range funcsWithError {
			// aName, err := CustomFunc(a.Name)
			// if err != nil {
			//	return Bar{}, err
			// }
			g.Add(List(Id(argsWithIndex(from.Name, 0)+fn.In.Name), Id("err")).Op(":=").Qual(fn.Fn.PkgPath, fn.Fn.Name).Call(Id(argsWithIndex(from.Name, 0)).Dot(fn.In.Name)))
			g.Add(returnOnError.Clone())
		}
	}

	genEmbeddedStructMethodsWithError := func(g *Group) {
		for _, fn := range embeddedStructMethodsWithError {
			// aName, err := c.struct.CustomMethod(a.Name)
			// if err != nil {
			//	return Bar{}, err
			// }
			g.Add(List(Id(argsWithIndex(from.Name, 0)+fn.In.Name), Id("err")).Op(":=").Id("c").Dot(fn.structName).Dot(fn.Fn.Name).Call(Id(argsWithIndex(from.Name, 0)).Dot(fn.In.Name)))
			g.Add(returnOnError.Clone())
		}
	}

	genReturnType := func(s *Statement) {
		if fn.Error != nil {
			// (Bar, nil)
			s.Add(Parens(List(
				Qual(relativeTo(pkgPath, to.Type.PkgPath), to.Type.Type),
				Id("error"),
			)))
		} else {
			// (Bar)
			s.Add(Qual(relativeTo(pkgPath, to.Type.PkgPath), to.Type.Type))
		}
	}

	f.Func().
		Params(Id("c").Op("*").Id(typeName)). // (c *Converter)
		Id(fnName).                           // mapMainAToMainB
		Params(
			Id(argsWithIndex(from.Name, 0)).Qual(relativeTo(pkgPath, from.Type.PkgPath), from.Type.Type),
		). // (a A)
		Do(genReturnType).
		BlockFunc(func(g *Group) {
			// aName, err := a.Name()
			// if err != nil {
			//	return Bar{}, err
			// }
			genMethodsWithError(g)

			// aName, err := CustomFunc(a.Name)
			// if err != nil {
			//	return Bar{}, err
			// }
			genFuncsWithError(g)

			// aName, err := c.struct.CustomMethod(a.Name)
			// if err != nil {
			//	return Bar{}, err
			// }
			genEmbeddedStructMethodsWithError(g)

			g.Add(ReturnFunc(func(g *Group) {
				if fn.Error != nil {
					// return Bar{}, nil
					g.Add(
						List(
							Qual(relativeTo(pkgPath, to.Type.PkgPath), to.Type.Type).Values(dict),
							Id("nil"),
						),
					)
				} else {
					// return Bar{}
					g.Add(Qual(relativeTo(pkgPath, to.Type.PkgPath), to.Type.Type).Values(dict))
				}
			}))
		}).Line()
	return f
}

func (g *Generator) generateUsePrivateMapper(f *jen.File, fn mapper.Func) {
	var (
		pkgPath  = g.opt.PkgPath
		typeName = g.opt.TypeName
	)
	// Output:
	// func (c *Converter) Convert(a A) (B, error) {
	//   *body*
	// }

	// Where body is one of these scenario.
	// No error
	// return c.mapMainAToMainB(main.A)

	// Input pointer.
	// return c.mapMainAToMainB(*main.A)

	// Output pointer.
	// return *c.mapMainAToMainB(main.A)

	// Input/Output pointer.
	// return *c.mapMainAToMainB(*main.A)

	// With error and pointers.
	// mainB, err := c.mapMaihAToMainB(&main.A)
	// return *mainB, err

	from, to := fn.From, fn.To
	if from.Type.IsSlice != to.Type.IsSlice {
		panic("mapper: slice to no-slice and vice versa is not allowed")
	}
	isSlice := from.Type.IsSlice
	inType := Qual(relativeTo(pkgPath, from.Type.PkgPath), from.Type.Type)
	outType := Qual(relativeTo(pkgPath, to.Type.PkgPath), to.Type.Type)

	genInputType := func(g *Group) {
		g.Add(
			Id(argsWithIndex(from.Name, 0)).Do(func(s *Statement) {
				if from.Type.IsSlice {
					s.Add(Index())
				}
			}).Op(pointerOp(from.Type, "*")).Add(inType),
		)
	}

	genReturnType := func(s *Statement) {
		if fn.Error != nil {
			// (*Bar, nil)
			s.Add(Parens(ListFunc(func(g *Group) {
				g.Add(
					Op(pointerOp(to.Type, "*")).Do(func(rs *Statement) {
						if to.Type.IsSlice {
							rs.Add(Index())
						}
					}).Add(outType))
				g.Add(Id("error"))
			})))
		} else {
			// (*Bar)
			s.Add(
				Op(pointerOp(to.Type, "*")).Do(func(s *Statement) {
					if to.Type.IsSlice {
						s.Add(Index())
					}
				}).Add(outType),
			)
		}
	}

	f.Func().
		Params(Id("c").Op("*").Id(typeName)). // (c *Converter)
		Id(fn.Name).ParamsFunc(genInputType). // Convert(a *A)
		Do(genReturnType).                    // (*B, error)
		BlockFunc(func(g *Group) {
			if isSlice {
				// var err error
				// res := make([]B, len(a))
				// for i, s := range a {
				//   res[i], err = c.mapMainAToMainB(s)
				//   if err != nil { return err }
				// }
				// return res, nil
				if fn.Error != nil {
					g.Add(Var().Id("err").Id("error"))
				}
				g.Add(Id("res").Op(":=").Make(List(Index().Add(outType), Len(Id(argsWithIndex(from.Name, 0))))))
				g.Add(For(List(Id("i"), Id("s")).Op(":=").Range().Id(argsWithIndex(from.Name, 0))).BlockFunc(func(g *Group) {
					if fn.Error != nil {
						g.Add(List(
							Id("res").Index(Id("i")),
							Id("err"),
						).Op("=").Id("c").Dot(fn.NormalizedName()).Call(Id("s")))
						g.Add(If(Id("err").Op("!=").Id("nil")).Block(ReturnFunc(func(g *Group) {
							if isSlice {
								g.Add(List(Id("nil"), Id("err")))
							} else {
								g.Add(List(outType.Clone().Values(), Id("err")))
							}
						})))
					} else {
						g.Add(Id("res").Index(Id("i")).Op("=").Id("c").Dot(fn.NormalizedName()).Call(Id("s")))
					}
				}))

				if fn.Error != nil {
					// return res, nil
					g.Add(Return(List(Id("res"), Id("nil"))))
				} else {
					// return res
					g.Add(Return(Id("res")))
				}
			} else {
				// Ignore pointers.
				g.Add(Return(Id("c").Dot(fn.NormalizedName()).Call(Id(argsWithIndex(from.Name, 0))))) // return c.mapMainAToMainB(a)
			}
		}).Line()
}

func relativeTo(pkgPath, fieldPkgPath string) string {
	if pkgPath == fieldPkgPath {
		return ""
	}
	return fieldPkgPath
}

func pointerOp(m *mapper.Type, op string) string {
	if !m.IsPointer {
		return ""
	}
	return op
}

func argsWithIndex(name string, index int) string {
	return fmt.Sprintf("%s%d", name, index)
}
