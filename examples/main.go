package main

import (
	"fmt"
	"log"
	"strconv"

	"github.com/alextanhongpin/mapper"
	"github.com/alextanhongpin/mapper/examples/bar"
	"github.com/alextanhongpin/mapper/examples/foo"
	"github.com/dave/jennifer/jen"
	. "github.com/dave/jennifer/jen"
	"github.com/google/uuid"
)

const Generator = "mapper"

type Task struct {
	Name string
}

type Foo struct {
	Age  int
	Name string
	Task Task
	ID   uuid.UUID
	//Remarks string // Fail with extra fields now.
	// CustomName `mapper:"YourName"`
	// CustomMapper `mapper:"github.com/yourorganization/yourpackage/struct.Method"`
	// CustomInterface `mapper:"github.com/yourorganization/yourpackage/interface.Method"`
	// CustomFunction`mapper:"github.com/yourorganization/yourpackage.funcName"`
}

func CustomConverter(a string) int {
	i, _ := strconv.Atoi(a)
	return i
}

//go:generate go run main.go -type Converter
type Converter interface {
	Convert(a Foo) (Bar, error) // Accepts err.
	ConvertImport(f foo.Foo) (b bar.Bar)
	ConvertImportPointer(f *foo.Foo) (b *bar.Bar)
	//ConvertFoo(a []Foo) ([]Bar, error) // Accepts err.
}

type Bar struct {
	Name string
	Age  int
	Task Task
	ID   uuid.UUID
}

func main() {
	if err := mapper.New(generateConverterFromFields); err != nil {
		log.Fatalln(err)
	}
}

func generateConverterFromFields(opt mapper.Option) error {
	var (
		pkgName    = opt.PkgName
		pkgPath    = opt.PkgPath
		structName = opt.StructName
		converters = opt.Converters
		out        = opt.Out
	)

	f := NewFile(pkgName) // e.g. main
	f.PackageComment(fmt.Sprintf("Code generated by %s, DO NOT EDIT.", Generator))

	generateConverter(f, structName)
	generateConverterConstructor(f, structName)
	for _, converter := range converters {
		generateConvertMethod(f, pkgPath, structName, converter)
	}

	return f.Save(out) // e.g. main_gen.go
}

func generateConverter(f *jen.File, structName string) {
	// Output:
	//type Converter struct {
	//}

	f.Type().Id(structName).Struct().Line()
}

func generateConverterConstructor(f *jen.File, structName string) {
	// Output:
	// func NewConverter() *Converter {
	//   return &Converter{
	//   }
	// }

	f.Func().Id(fmt.Sprintf("New%s", structName)).Params().Op("*").Id(structName).Block(
		Return(Op("&").Id(structName).Values(Dict{})),
	).Line()
}

func generateConvertMethod(f *jen.File, pkgPath, structName string, converter mapper.ConverterFunc) {
	// Output:
	// func (c *Converter) Convert(a A) B {
	//   return B{
	//     Name: a.Name,
	//   }
	// }

	from, to := converter.From, converter.To

	dict := Dict{}
	for key, f := range from.Fields {
		t := to.Fields[key]
		dict[Id(t.Name)] = Id(from.Name).Dot(f.Name)
	}

	var toReturnPtr, toPtr string
	if converter.To.Field.IsPointer {
		toPtr = "&"
		toReturnPtr = "*"
	}

	var fromPtr string
	if converter.From.Field.IsPointer {
		fromPtr = "*"
	}

	f.Func().Params(Id("c").Op("*").Id(structName)).Id(converter.Name).Params(Id(from.Name).Op(fromPtr).Qual(skipImportIfBelongToSamePackage(pkgPath, from.Field.PkgPath), from.Field.Type)).Op(toReturnPtr).Qual(skipImportIfBelongToSamePackage(pkgPath, to.Field.PkgPath), to.Field.Type).Block(
		Return(Op(toPtr).Qual(skipImportIfBelongToSamePackage(pkgPath, to.Field.PkgPath), to.Field.Type).Values(dict)),
	).Line()
}

func skipImportIfBelongToSamePackage(pkgPath, fieldPkgPath string) string {
	if pkgPath == fieldPkgPath {
		return ""
	}
	return fieldPkgPath
}
